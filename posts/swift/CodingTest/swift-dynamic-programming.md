---
title: 'Dynamic Programming'
date: '2024-01-10 13:40:30'
tags: '코딩테스트,Swift'
desc: '다이나믹 프로그래밍의 유형'
---
# Coin - Dynamic Programming

### 다이나믹 프로그래밍 문제에서 소개되는 유명한 문제입니다.
> Fibonacci를 dynamic으로 구성하는 유형에서 두번째로 유명한 유형입니다.

- That said, the Core Logic ->
- 얼마나 많은 수의 코인이 필요한지, 얼마나 적은 수의 코인이 필요한지,
- 0의 코인이 필요하다면 0인 코인이 1개 필요합니다. (ㅇㅎ?) 
- [1, 2, 5]의 코인을 가진다고 생각해 봅시다.
- 그리고 target을 6으로 잡아 봅시다. 그러면 5와 1 , 2코인 3개 의 조합으로 나타낼수 있습니다.
- 처음 base 배열을 [0, Int.max, Int.max, Int.max, Int.max, Int.max, Int.max]
- target 의 값의 크기만큼 배열의 길이를 설정합니다.
- 배열의 인덱스의 값은 각 인덱스를 구성하는 코인의 최솟값으로 구성해봅시다.
- dp[i] i번째 에 얼마만큼의 코인이 필요한지 집어넣으면 됩니다.
- 0번째는 0개 , 1번째는 1코인이 1개 필요합니다.
- 2번째는 2코인을 얻을수 있는 가장 적은 최솟값이 필요합니다.
- 1번째 dp 배열에 저장되어있는 1 을 얻는데 소요되는 최솟값 과 2를 얻는 코인의 갯수로 두가지 경우로 나누어 질수 - 있습니다.
- dp[1] 의 1를 얻는데 최솟값 max(dp[1] + 1, "2코인을 얻는데 소요되는 최솟값") 
- 여기서 "2코인을 얻는데 소요되는 최솟값" == (처음 인수로 받은 코인의 종류에 포함되는 값이기에 1이 됩니다.)
- 마찬가지로 5코인 도 인수로 포함되어있기에 base 배열의 5번째 값은 5가 될것입니다. (index로는 4)
- 그럼 처음 인수를 받은 코인으로 base 배열을 구성하면
- [0, 1, 1, Int.max, Int.max, 1, Int.max] 로 구성할 수 있습니다.
- 그럼 여기서 점화식을 도출해 낼 수 있을거 같습니다.
- base 배열은 i 코인 만큼 이루는데 최소한으로 쓰는 코인의 갯수이기에
- dp[i - 1] + 1 => dp[i - 1] 를 이루는 최소한의 코인과 인수로 주어진 1코인
- dp[i - 2] + 2 => dp[i - 2] 를 이루는 최소한의 코인과 인수로 주어진 2코인
- dp[i - 5] + 5 => dp[i - 5] 를 이루는 최소한의 코인과 인수로 주어진 5코인
- dp[i] = min(dp[i - 1] + 1, dp[i - 2] + 1, dp[i - 5] + 1)
- gtm-session-fetcher
